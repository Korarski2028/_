from flask import Flask, render_template, request, send_file, redirect, url_for
import pandas as pd
import glob
import os

app = Flask(__name__)

app.config['SEND_FILE_MAX_AGE_DEFAULT'] = 0

@app.after_request
def add_header(response):
    response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0, max-age=0'
    response.headers['Pragma'] = 'no-cache'
    response.headers['Expires'] = '-1'
    return response

# Path to the directory containing the Excel files
EXCEL_DIR = os.path.dirname(os.path.abspath(__file__))

def read_options(filename):
    """Reads options from a text file."""
    try:
        with open(os.path.join(EXCEL_DIR, filename), 'r') as f:
            options = [line.strip() for line in f.readlines()]
        return options
    except FileNotFoundError:
        return []

@app.route('/')
def index():
    project_files = [os.path.basename(f) for f in glob.glob(os.path.join(EXCEL_DIR, 'Tracker*.xlsx'))]
    
    selected_project = request.args.get('project', project_files[0] if project_files else None)
    
    if not selected_project or not os.path.exists(os.path.join(EXCEL_DIR, selected_project)):
        return "No Tracker files found or selected project does not exist."

    df = pd.read_excel(os.path.join(EXCEL_DIR, selected_project))
    df.columns = df.columns.str.strip()
    df['status'] = df['status'].str.lower()

    # Summary by Status
    status_summary = df['status'].value_counts().reset_index()
    status_summary.columns = ['Status', 'Count']

    # Summary by Vendor
    vendor_summary = df['Vendor'].value_counts().reset_index()
    vendor_summary.columns = ['Vendor', 'Count']

    # Pie chart data
    pie_chart_statuses = df['status'].value_counts()
    pie_chart_labels = pie_chart_statuses.index.tolist()
    pie_chart_data_values = pie_chart_statuses.values.tolist()
    
    pie_chart_colors = {
        'completed': 'rgba(75, 192, 192, 0.6)',
        'in progress': 'rgba(54, 162, 235, 0.6)',
        'pending': 'rgba(255, 206, 86, 0.6)',
        'on hold': 'rgba(255, 99, 132, 0.6)',
        'not started': 'rgba(201, 203, 207, 0.6)', # Gray for not started
    }
    
    pie_chart_background_colors = [pie_chart_colors.get(status, 'rgba(201, 203, 207, 0.6)') for status in pie_chart_labels]

    pie_chart_data = {
        'labels': pie_chart_labels,
        'data': pie_chart_data_values,
        'backgroundColor': pie_chart_background_colors,
    }

    # Grouped bar chart data: Cluster status by vCenter
    vcenters = df['vCenter'].unique()
    charts_data = []
    for vcenter in vcenters:
        vcenter_df = df[df['vCenter'] == vcenter]
        cluster_status_summary = vcenter_df.groupby(['cluster name', 'status']).size().unstack(fill_value=0)
        
        if cluster_status_summary.empty:
            continue

        cluster_chart_data = {
            'vcenter': vcenter,
            'labels': cluster_status_summary.index.tolist(),
            'datasets': []
        }
        
        status_colors = {
            'on hold': 'rgba(255, 159, 64, 0.6)',
            'completed': 'rgba(75, 192, 192, 0.6)',
            'in progress': 'rgba(54, 162, 235, 0.6)',
            'not started': 'rgba(255, 99, 132, 0.6)',
            'pending': 'rgba(255, 206, 86, 0.6)',
        }

        for status in cluster_status_summary.columns:
            cluster_chart_data['datasets'].append({
                'label': status,
                'data': cluster_status_summary[status].tolist(),
                'backgroundColor': status_colors.get(status, 'rgba(201, 203, 207, 0.6)'),
                'barThickness': 48,
            })
        charts_data.append(cluster_chart_data)

    # Completed and Pending by Cluster
    completed_df = df[df['status'] == 'completed']
    completed_by_cluster = completed_df.groupby('cluster name').size().reset_index(name='Completed')

    cluster_pending_statuses = ['on hold', 'not started']
    pending_df = df[df['status'].isin(cluster_pending_statuses)]
    pending_by_cluster = pending_df.groupby('cluster name').size().reset_index(name='Pending')

    cluster_summary = pd.merge(completed_by_cluster, pending_by_cluster, on='cluster name', how='outer').fillna(0)
    cluster_summary.rename(columns={'cluster name': 'Cluster Name'}, inplace=True)
    cluster_summary['Pending'] = cluster_summary['Pending'].astype(int)
    cluster_summary['Completed'] = cluster_summary['Completed'].astype(int)


    # Pending or not started by Model
    pending_statuses = ['pending', 'not started', 'on hold']
    pending_df = df[df['status'].isin(pending_statuses)]
    pending_by_model = pending_df.groupby('model').size().reset_index(name='Count')
    pending_by_model.columns = ['Model', 'Count']

    return render_template('index.html', 
                           projects=project_files,
                           selected_project=selected_project,
                           status_summary=status_summary.to_html(classes='table table-striped', index=False),
                           vendor_summary=vendor_summary.to_html(classes='table table-striped', index=False),
                           completed_by_cluster=cluster_summary.to_html(classes='table table-striped', index=False),
                           pending_by_model=pending_by_model.to_html(classes='table table-striped', index=False),
                           pie_chart_data=pie_chart_data,
                           charts_data=charts_data)

# Editor routes
@app.route('/editor')
def editor_index():
    """Displays a list of Tracker*.xlsx files for editing."""
    files = [os.path.basename(f) for f in glob.glob(os.path.join(EXCEL_DIR, 'Tracker*.xlsx'))]
    descriptions = {}
    try:
        with open(os.path.join(EXCEL_DIR, 'description.txt'), 'r') as f:
            for line in f:
                parts = line.strip().split(',', 1)
                if len(parts) == 2:
                    descriptions[parts[0] + '.xlsx'] = parts[1]
    except FileNotFoundError:
        pass
    return render_template('editor_file_list.html', files=files, descriptions=descriptions)

@app.route('/editor/view/<filename>')
def editor_view_file(filename):
    """Reads data from the selected Excel file and displays it in an editable HTML table."""
    try:
        file_path = os.path.join(EXCEL_DIR, filename)
        df = pd.read_excel(file_path)
        df.columns = [str(col) for col in df.columns]
        
        engineers = read_options('engineers.txt')
        statuses = read_options('status.txt')
        
        return render_template('editor.html', 
                               data=df.to_dict(orient='records'), 
                               columns=df.columns,
                               engineers=engineers,
                               statuses=statuses,
                               filename=filename)
    except FileNotFoundError:
        return "Error: File not found."
    except Exception as e:
        return f"An error occurred: {e}"

@app.route('/editor/update/<filename>', methods=['POST'])
def editor_update(filename):
    """
    Receives updated data from the form and saves it to the Excel file.
    """
    try:
        file_path = os.path.join(EXCEL_DIR, filename)
        data = request.form.to_dict(flat=False)
        df = pd.DataFrame(data)
        df.to_excel(file_path, index=False)
        return redirect(url_for('editor_view_file', filename=filename))
    except Exception as e:
        return f"An error occurred while updating: {e}"

@app.route('/editor/export/<filename>')
def editor_export(filename):
    """
    Allows the user to download the Excel file.
    """
    try:
        file_path = os.path.join(EXCEL_DIR, filename)
        return send_file(file_path, as_attachment=True)
    except FileNotFoundError:
        return "Error: File not found."
    except Exception as e:
        return f"An error occurred: {e}"

if __name__ == '__main__':
    app.run(debug=True)